<?php

namespace Redking\ParseBundle;

use Doctrine\Common\Cache\Cache;
use Doctrine\Common\Cache\Psr6\DoctrineProvider;
use Doctrine\Persistence\Mapping\Driver\MappingDriver;
use InvalidArgumentException;
use Psr\Cache\CacheItemPoolInterface;
use Redking\ParseBundle\Exception\RedkingParseException;
use Redking\ParseBundle\Mapping\DefaultNamingStrategy;
use Redking\ParseBundle\Mapping\DefaultObjectListenerResolver;
use ProxyManager\Configuration as ProxyManagerConfiguration;
use ProxyManager\Factory\LazyLoadingGhostFactory;
use ProxyManager\GeneratorStrategy\EvaluatingGeneratorStrategy;
use ProxyManager\GeneratorStrategy\FileWriterGeneratorStrategy;
use Redking\ParseBundle\Proxy\FileLocator;

/**
 * Configuration container for the Doctrine DBAL.
 *
 * @since    2.0
 *
 * @author   Guilherme Blanco <guilhermeblanco@hotmail.com>
 * @author   Jonathan Wage <jonwage@gmail.com>
 * @author   Roman Borschel <roman@code-factory.org>
 *
 * @internal When adding a new configuration option just write a getter/setter
 *           pair and add the option to the _attributes array with a proper default value.
 */
class Configuration
{
    /**
     * Never autogenerate a proxy/hydrator/persistent collection and rely that
     * it was generated by some process before deployment. Copied from
     * \Doctrine\Common\Proxy\AbstractProxyFactory.
     */
    public const AUTOGENERATE_NEVER = 0;

    /**
     * Always generates a new proxy/hydrator/persistent collection in every request.
     *
     * This is only sane during development.
     * Copied from \Doctrine\Common\Proxy\AbstractProxyFactory.
     */
    public const AUTOGENERATE_ALWAYS = 1;

    /**
     * Autogenerate the proxy/hydrator/persistent collection class when the file does not exist.
     *
     * This strategy causes a file exists call whenever any proxy/hydrator is used the
     * first time in a request. Copied from \Doctrine\Common\Proxy\AbstractProxyFactory.
     */
    public const AUTOGENERATE_FILE_NOT_EXISTS = 2;

    /**
     * Generate the proxy/hydrator/persistent collection classes using eval().
     *
     * This strategy is only sane for development.
     * Copied from \Doctrine\Common\Proxy\AbstractProxyFactory.
     */
    public const AUTOGENERATE_EVAL = 3;

    /**
     * Array of attributes for this configuration instance.
     *
     * @var array
     */
    protected $_attributes = array();

    /** @var CacheItemPoolInterface|null */
    private $metadataCache;

    /** @var ProxyManagerConfiguration */
    private $proxyManagerConfiguration;

    /** @var int */
    private $autoGenerateProxyClasses = self::AUTOGENERATE_EVAL;

    public function __construct()
    {
        $this->proxyManagerConfiguration = new ProxyManagerConfiguration();
        $this->setAutoGenerateProxyClasses(self::AUTOGENERATE_FILE_NOT_EXISTS);
    }

    /**
     * Adds a namespace under a certain alias.
     *
     * @param string $alias
     * @param string $namespace
     */
    public function addEntityNamespace($alias, $namespace)
    {
        $this->_attributes['entityNamespaces'][$alias] = $namespace;
    }

    /**
     * Resolves a registered namespace alias to the full namespace.
     *
     * @param string $entityNamespaceAlias
     *
     * @return string
     *
     * @throws ORMException
     */
    public function getEntityNamespace($entityNamespaceAlias)
    {
        if (!isset($this->_attributes['entityNamespaces'][$entityNamespaceAlias])) {
            throw new RedkingParseException("Unknown Entity namespace alias '$entityNamespaceAlias'.");
        }

        return trim($this->_attributes['entityNamespaces'][$entityNamespaceAlias], '\\');
    }

    /**
     * Sets the entity alias map.
     *
     * @param array $entityNamespaces
     */
    public function setEntityNamespaces(array $entityNamespaces)
    {
        $this->_attributes['entityNamespaces'] = $entityNamespaces;
    }

    /**
     * Retrieves the list of registered entity namespace aliases.
     *
     * @return array
     */
    public function getEntityNamespaces()
    {
        return $this->_attributes['entityNamespaces'];
    }

    /**
     * Sets the cache driver implementation that is used for metadata caching.
     *
     * @param MappingDriver $driverImpl
     *
     * @todo Force parameter to be a Closure to ensure lazy evaluation
     *       (as soon as a metadata cache is in effect, the driver never needs to initialize).
     */
    public function setMetadataDriverImpl(MappingDriver $driverImpl)
    {
        $this->_attributes['metadataDriverImpl'] = $driverImpl;
    }

    /**
     * Gets the cache driver implementation that is used for the mapping metadata.
     *
     * @return MappingDriver|null
     *
     * @throws ORMException
     */
    public function getMetadataDriverImpl()
    {
        return isset($this->_attributes['metadataDriverImpl'])
            ? $this->_attributes['metadataDriverImpl']
            : null;
    }

    /**
     * Sets naming strategy.
     *
     * @since 2.3
     *
     * @param DefaultNamingStrategy $namingStrategy
     */
    public function setNamingStrategy(DefaultNamingStrategy $namingStrategy)
    {
        $this->_attributes['namingStrategy'] = $namingStrategy;
    }

    /**
     * Gets naming strategy..
     *
     * @since 2.3
     *
     * @return NamingStrategy
     */
    public function getNamingStrategy()
    {
        if (!isset($this->_attributes['namingStrategy'])) {
            $this->_attributes['namingStrategy'] = new DefaultNamingStrategy();
        }

        return $this->_attributes['namingStrategy'];
    }

    /**
     * Sets the directory where Doctrine generates any necessary proxy class files.
     *
     * @param string $dir
     */
    public function setProxyDir($dir)
    {
        $this->getProxyManagerConfiguration()->setProxiesTargetDir($dir);

        // Recreate proxy generator to ensure its path was updated
        if ($this->autoGenerateProxyClasses !== self::AUTOGENERATE_FILE_NOT_EXISTS) {
            return;
        }

        $this->setAutoGenerateProxyClasses($this->autoGenerateProxyClasses);
    }

    /**
     * Gets the directory where Doctrine generates any necessary proxy class files.
     *
     * @return string
     */
    public function getProxyDir()
    {
        return $this->getProxyManagerConfiguration()->getProxiesTargetDir();
    }

    /**
     * Gets the namespace where proxy classes reside.
     *
     * @return string
     */
    public function getProxyNamespace()
    {
        return $this->getProxyManagerConfiguration()->getProxiesNamespace();
    }

    /**
     * Sets the namespace where proxy classes reside.
     *
     * @param string $ns
     */
    public function setProxyNamespace($ns)
    {
        $this->getProxyManagerConfiguration()->setProxiesNamespace($ns);
    }

    /**
     * Gets a boolean flag that indicates whether proxy classes should always be regenerated
     * during each script execution.
     *
     * @return bool|int
     */
    public function getAutoGenerateProxyClasses()
    {
        return $this->autoGenerateProxyClasses;
    }

    /**
     * Sets an int flag that indicates whether proxy classes should always be regenerated
     * during each script execution.
     *
     * @throws InvalidArgumentException If an invalid mode was given.
     */
    public function setAutoGenerateProxyClasses(int $mode): void
    {
        $this->autoGenerateProxyClasses = $mode;
        $proxyManagerConfig             = $this->getProxyManagerConfiguration();

        switch ($mode) {
            case self::AUTOGENERATE_FILE_NOT_EXISTS:
                $proxyManagerConfig->setGeneratorStrategy(new FileWriterGeneratorStrategy(
                    new FileLocator($proxyManagerConfig->getProxiesTargetDir())
                ));

                break;
            case self::AUTOGENERATE_EVAL:
                $proxyManagerConfig->setGeneratorStrategy(new EvaluatingGeneratorStrategy());

                break;
            default:
                throw new InvalidArgumentException('Invalid proxy generation strategy given - only AUTOGENERATE_FILE_NOT_EXISTS and AUTOGENERATE_EVAL are supported.');
        }
    }

    /**
     * Gets the logger callable.
     *
     * @return callable
     */
    public function getLoggerCallable()
    {
        return isset($this->_attributes['loggerCallable']) ? $this->_attributes['loggerCallable'] : null;
    }

    /**
     * Set the logger callable.
     *
     * @param callable $loggerCallable
     */
    public function setLoggerCallable($loggerCallable)
    {
        $this->_attributes['loggerCallable'] = $loggerCallable;
    }

    /**
     * Gets the profiler callable.
     *
     * @return callable
     */
    public function getProfilerCallable()
    {
        return isset($this->_attributes['profilerCallable']) ? $this->_attributes['profilerCallable'] : null;
    }

    /**
     * Set the profiler callable.
     *
     * @param callable $loggerCallable
     */
    public function setProfilerCallable($profilerCallable)
    {
        $this->_attributes['profilerCallable'] = $profilerCallable;
    }

    /**
     * Set the entity listener resolver.
     *
     * @since 2.4
     *
     * @param DefaultObjectListenerResolver $resolver
     */
    public function setObjectListenerResolver(DefaultObjectListenerResolver $resolver)
    {
        $this->_attributes['ObjectListenerResolver'] = $resolver;
    }

    /**
     * Get the entity listener resolver.
     *
     * @since 2.4
     *
     * @return DefaultObjectListenerResolver
     */
    public function getObjectListenerResolver()
    {
        if (!isset($this->_attributes['ObjectListenerResolver'])) {
            $this->_attributes['ObjectListenerResolver'] = new DefaultObjectListenerResolver();
        }

        return $this->_attributes['ObjectListenerResolver'];
    }

    /**
     * Define Parse connection parameters.
     *
     * @param array $parameters
     */
    public function setConnectionParameters(array $parameters)
    {
        $this->_attributes['connectionParams'] = $parameters;
    }

    /**
     * Get Parse connection parameters.
     *
     * @return array
     */
    public function getConnectionParameters()
    {
        if (!isset($this->_attributes['connectionParams'])) {
            throw new \Exception("Connection parameters must be defined.");
        }

        return $this->_attributes['connectionParams'];
    }

    /**
     * Gets the alwaysMaster.
     *
     * @return boolean
     */
    public function getAlwaysMaster()
    {
        return isset($this->_attributes['alwaysMaster']) ? $this->_attributes['alwaysMaster'] : true;
    }

    /**
     * Set the alwaysMaster.
     *
     * @param boolean $alwaysMaster
     */
    public function setAlwaysMaster($alwaysMaster)
    {
        $this->_attributes['alwaysMaster'] = $alwaysMaster;
    }

    /**
     * Gets the cache driver implementation that is used for metadata caching.
     *
     * @return \Doctrine\Common\Cache\Cache
     */
    public function getMetadataCacheImpl()
    {
        return isset($this->_attributes['metadataCacheImpl']) ? $this->_attributes['metadataCacheImpl'] : null;
    }

    /**
     * Sets the cache driver implementation that is used for metadata caching.
     *
     * @param \Doctrine\Common\Cache\Cache $cacheImpl
     */
    public function setMetadataCacheImpl(Cache $cacheImpl)
    {
        $this->_attributes['metadataCacheImpl'] = $cacheImpl;
    }

    public function getMetadataCache(): ?CacheItemPoolInterface
    {
        return $this->metadataCache;
    }

    public function setMetadataCache(CacheItemPoolInterface $cache): void
    {
        $this->metadataCache                   = $cache;
        $this->_attributes['metadataCacheImpl'] = DoctrineProvider::wrap($cache);
    }

    public function getProxyManagerConfiguration(): ProxyManagerConfiguration
    {
        return $this->proxyManagerConfiguration;
    }
}
